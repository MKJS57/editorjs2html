// Editorjs2Html

use anyhow::{anyhow, Result};

mod models;

use models::*;

/// Converts an Editor.js JSON string into an HTML representation.
///
/// This function takes a JSON-formatted string generated by [Editor.js](https://editorjs.io/)
/// and converts it into HTML. It is useful for rendering rich text content stored in Editor.js format
/// in web applications.
///
/// # Arguments
///
/// * `str` - A string slice containing the Editor.js JSON.
///
/// # Returns
///
/// * `Ok(String)` - The generated HTML string if the conversion is successful.
/// * `Err(anyhow::Error)` - An error if the JSON is invalid or cannot be parsed.
///
/// # Example
///
/// ```
/// let editor_json = r#"{
///     "time": 1612345678901,
///     "blocks": [
///         { "type": "paragraph", "data": { "text": "Hello, world!" } },
///         { "type": "header", "data": { "text": "Welcome", "level": 2 } }
///     ],
///     "version": "2.22.2"
/// }"#;
///
/// let html = to_html(editor_json).unwrap();
/// assert_eq!(html, "<p>Hello, world!</p><h2>Welcome</h2>");
/// ```
///
/// # Errors
///
/// This function may return an error if:
/// * The input is not valid JSON.
/// * The JSON structure does not conform to Editor.js format.
/// * The function encounters an unsupported block type.
///
/// # Notes
///
/// * The function assumes that the input follows the standard [Editor.js JSON format](https://editorjs.io/base-concepts).
/// * Not all Editor.js block types may be supported in the implementation.
pub fn to_html(str: &str) -> Result<String> {
    let document: Document = serde_json::from_str(str)
        .map_err(|e| anyhow!("Error while parsing to blocks: {}", e.to_string()))?;

    let mut html_string = String::new();
    for block in document.blocks {
        let data = block.data;
        match block.r#type.to_lowercase().as_str() {
            "header" | "heading" => {
                html_string.push_str(&format!(
                    "<div class=\"js-head\"{s}><h{l}>{t}</h{l}>",
                    l = data.level.unwrap_or(4),
                    t = data.text.unwrap_or_default(),
                    s = if let Some(align) = data.align.clone() {
                        format!(" style=\"text-align: {};\"", align)
                    } else {
                        String::new()
                    }
                ));
            }
            "paragraph" => {
                html_string.push_str(&format!(
                    "<div class=\"js-para\"><p>{}</p></div>",
                    data.text.unwrap_or_default(),
                ));
            }
            "list" => {
                if let Some(items) = data.items {
                    match serde_json::from_value::<Vec<ListItem>>(items.clone()) {
                        Ok(items) => {
                            let style = data.style.unwrap_or_default().to_lowercase();
                            let tag = if style == "ordered" { "ol" } else { "ul" };
                            html_string.push_str(&format!(
                                "<div class=\"js-list\"><{t}>{i}</{t}></div>",
                                t = tag,
                                i = form_list(&items, tag)
                            ));
                        }
                        Err(_) => {
                            // If nested parsing fails, try parsing as a simple list of strings
                            match serde_json::from_value::<Vec<String>>(items) {
                                Ok(string_items) => {
                                    let style = data.style.unwrap_or_default().to_lowercase();
                                    let tag = if style == "ordered" { "ol" } else { "ul" };

                                    let mut list = String::new();
                                    for item in string_items {
                                        list.push_str(&format!("<li>{}</li>", item));
                                    }
                                    html_string.push_str(&format!(
                                        "<div class=\"js-list\"><{t}>{i}</{t}></div>",
                                        t = tag,
                                        i = list
                                    ));
                                }
                                Err(e) => {
                                    log::error!("Parse list error: {}", e);
                                }
                            }
                        }
                    }
                }
            }
            "table" => {
                let mut table_data = String::new();
                let content: Vec<Vec<String>> = if let Some(value) = data.content {
                    serde_json::from_value(value).unwrap_or_default()
                } else {
                    vec![]
                };
                let with_heading = data.with_headings.unwrap_or_default();

                for (idx, ele) in content.iter().enumerate() {
                    let tag = if idx == 0 && with_heading { "th" } else { "td" };
                    table_data.push_str(&form_table(ele, tag));
                }
                html_string.push_str(&format!(
                    "<div class=\"js-table\"><table>{}</table><div>",
                    table_data.as_str()
                ));
            }
            "quote" => {
                html_string.push_str(&format!(
                    "<div class=\"js-quote\"><blockquote style=\"text-align: {}\">{}</blockquote> - {}</div>",
                    data.alignment.unwrap_or_default(),
                    data.text.unwrap_or_default()
                    ,data.caption.unwrap_or_default()
                ));
            }
            "checklist" => {
                if let Some(value) = data.items {
                    let items: Vec<ChecklistItem> =
                        serde_json::from_value(value).unwrap_or_default();
                    let mut checklist = String::new();
                    for item in items {
                        checklist.push_str(&format!(
                            "<div class=\"js-checkbox\"><input type=\"checkbox\" {} disabled> {}</div>",
                            if item.checked { "checked" } else { "" },
                            item.text
                        ));
                    }
                    html_string
                        .push_str(&format!("<div class=\"js-checklist\">{}</div>", checklist));
                }
            }
            "code" => {
                html_string.push_str(&format!(
                    "<div class=\"js-code\"><pre><code>{}</code></pre></div>",
                    data.code.unwrap_or_default()
                ));
            }
            "link" => {
                html_string.push_str(&format!(
                    "<div class=\"js-link\"><a href=\"{}\" target=\"_blank\">{}</a></div>",
                    data.url.unwrap_or_default(),
                    data.text.unwrap_or_default()
                ));
            }
            "inlinetext" => {
                let mut text = data.text.unwrap_or_default();
                if data.bold.unwrap_or_default() {
                    text = format!("<b>{}</b>", text);
                }
                if data.italic.unwrap_or_default() {
                    text = format!("<i>{}</i>", text);
                }
                if data.underline.unwrap_or_default() {
                    text = format!("<u>{}</u>", text);
                }
                if data.marker.unwrap_or_default() {
                    text = format!("<mark>{}</mark>", text);
                }
                if data.inline_code.unwrap_or_default() {
                    text = format!("<code>{}</code>", text);
                }
                html_string.push_str(&format!("<div class=\"js-inline\">{}</div>", text));
            }
            "warning" => {
                html_string.push_str(&format!(
                    "<div class=\"warning\"><strong>{}</strong><p>{}</p></div>",
                    data.title.unwrap_or_default(),
                    data.message.unwrap_or_default()
                ));
            }
            "image" => {
                if let Some(file) = data.file {
                    html_string.push_str(&format!(
                        "<div class=\"js-image\"><img src=\"{}\" alt=\"Image\">{}</div>",
                        file,
                        if let Some(caption) = data.caption {
                            format!("<p>{}</p>", caption)
                        } else {
                            String::new()
                        }
                    ));
                }
                if let Some(url) = data.url {
                    html_string.push_str(&format!(
                        "<div class=\"js-image\"><img src=\"{}\" alt=\"Image\"></div>",
                        url
                    ));
                }
            }
            "embed" => {
                if let Some(url) = data.url {
                    html_string.push_str(&format!(
                        "<div class=\"js-embed\"><iframe src=\"{}\" title=\"Embedded content\"></iframe>{}</div>",
                        url,
                        if let Some(caption) = data.caption {
                            format!("<p>{}</p>", caption)
                        } else {
                            String::new()
                        }
                    ));
                }
            }
            "raw" => html_string.push_str(&format!(
                "<div class=\"js-raw\">{}</div>",
                data.html.unwrap_or_default()
            )),
            "alert" => html_string.push_str(&format!(
                "<div class=\"js-alert js-alert-{} style=\"text-align: {};\">{}</div>",
                data.r#type.unwrap_or_default(),
                data.align.unwrap_or_default(),
                data.text.unwrap_or_default()
            )),
            _ => log::error!(
                "editor2html library doesn't support for the {}",
                block.r#type
            ),
        }
    }
    Ok(html_string)
}

fn form_list(items: &[ListItem], tag: &str) -> String {
    let mut list = String::new();
    for item in items {
        let sub_items = if !item.items.is_empty() {
            format!("<{t}>{i}</{t}>", t = tag, i = form_list(&item.items, tag))
        } else {
            String::new()
        };
        list.push_str(&format!("<li>{}{}</li>", item.content, sub_items));
    }
    list
}

fn form_table(data: &Vec<String>, tag: &str) -> String {
    let mut table_row = String::new();
    for ele in data {
        table_row.push_str(&format!("<{}>{}</{}>", tag, ele, tag));
    }
    format!("<tr>{}</tr>", table_row)
}
